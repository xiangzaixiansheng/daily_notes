

首先在rr级别下

1、加锁的默认单位是next-key-locak，左开右闭，等值查询时唯一索引退化为行锁

2、语句按照顺序的记录，对它的二级索引以及对应的主键索引加x锁，并在commit后释放。

总结

1、二级索引 => 加间隙锁gap lock => 找主键索引 =>加x锁 =>操作

2、等值查询时，唯一索引退化为行锁

在rc级别下，没有间隙锁(gap lock)一说。



锁按算法可分为

- 1. 记录锁（Record Lock）：单个行记录上的锁
  2. 间隙锁（Gap Lock）：锁定一个范围，但不包含记录本身
  3. 临键锁（Next-Key Lock，即 Gap Lock + Record Lock）：是记录锁与间隙锁的组合。它的封锁范围既包含索引记录，又包含索引区间，是一个左开右闭区间。临键锁的主要目的是为了避免幻读（Phantom Read）



二、定位锁

##### 查询在跑的trx的加锁情况

```
SELECT * FROM information_schema.INNODB_TRX;
```

一个INNOD_TRX 表的存储信息如上所示

- trx_id表示事务ID
- trx_isolation_level 表示事务隔离级别
- trx_rows_locked 表示当前加了多少个行级锁
- trx_tables_locked 表示当前加了多少个表级锁

1. innodb_locks 表主要记录了下面两个方面的锁信息

- - 如果一个事务想要获取某个锁但未获取到，则记录该锁信息
  - 如果一个事务获取到了锁，但是这个锁阻塞了别的事务，则记录该锁信息

1. innodb_lock_wait 表记录了某个事务是因为获取不到哪个事务持有的锁而阻塞的。

information_schema 数据库中的 innodb_locks 和 innodb_lock_wait 这两个表，在在 MySQL 8.0 中，这两个表已经被移除，可使用 performance_schema 数据库中的 data_locks 和data_locks_waits 代替。



##### 查询锁信息

```
select * from information_schema.INNODB_TRX where TRX_MYSQL_THREAD_ID = CONNECTION_ID();

//trx_id为上面查询出来的id
select * from performance_schema.data_locks where ENGINE_TRANSACTION_ID = trx_id;
```

##### 查询超时时间

```
show GLOBAL VARIABLES like "%innodb_lock_wait_timeout%";
```



##### 推荐使用：查询最后一次死锁信息

```
show engine innodb status，查看LATESTDETECTED DEADLOCK最后一次死锁信息
```



三、**如何查看和解决锁表**

```
show open tables where in_use > 0;
1. 查看表是否在使用

mysql>showopen tables where in_use >0 ;+----------+-------+--------+-------------+| Database |Table| In_use | Name_locked |+----------+-------+--------+-------------+| test     | t     |1|0|+----------+-------+--------+-------------+
```

1. show  processlist;
2.  查看数据库当前的进程

show processlist 是显示用户正在运行的线程，需要注意的是，除了 root 用户能看到所有正在运行的线程外，其他用户都只能看到自己正在运行的线程，看不到其它用户正在运行的线程。

1. 查看当前的事务

   ```
   SELECT*FROM information_schema.INNODB_TRX;               
   ```

1. 查看当前的锁和锁等待关系

​                -- MySQL 8.0版本前SELECT*FROM information_schema.INNODB_LOCKs;SELECT*FROM information_schema.INNODB_LOCK_WAITS;-- MySQL 8.0版本后SELECT*FROM performance_schema.data_locks;SELECT*FROM performance_schema.data_locks_waits;-- 该步骤，也可使用 show engine innodb status 查看SHOW ENGINE INNODB STATUS;复制代码              

1. 获取要结束的事务的线程ID

​                mysql >SELECT p.id,p.time,i.trx_id,i.trx_state,p.info >FROM INFORMATION_SCHEMA.PROCESSLIST p, INFORMATION_SCHEMA.INNODB_TRX i >WHERE p.id = i.trx_mysql_thread_id    >AND i.trx_state ='LOCK WAIT';+----+------+--------+-----------+-------------------------+| id |time| trx_id | trx_state | info                    |+----+------+--------+-----------+-------------------------+|41|27|23312| LOCK WAIT |deletefrom t where c=1|+----+------+--------+-----------+-------------------------+1rowinset (0.01 sec)复制代码              

1. 使用 kill 命令结束相应的事务

​                kill -9 [线程ID] #该示例中为41复制代码              